<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Security | Grygoriy Mykhalyuno]]></title>
  <link href="http://grygoriy.github.io/blog/categories/security/atom.xml" rel="self"/>
  <link href="http://grygoriy.github.io/"/>
  <updated>2013-10-12T01:02:37+03:00</updated>
  <id>http://grygoriy.github.io/</id>
  <author>
    <name><![CDATA[Grygoriy Mykhalyuno]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Prevent brute force attack with Spring Security]]></title>
    <link href="http://grygoriy.github.io/blog/2012/10/06/prevent-brute-force-attack-with-spring-security/"/>
    <updated>2012-10-06T15:58:00+03:00</updated>
    <id>http://grygoriy.github.io/blog/2012/10/06/prevent-brute-force-attack-with-spring-security</id>
    <content type="html"><![CDATA[<p>Spring Security can do lot of stuff for you. Account blocking, password salt. But what about brute force blocker. That what you have to do by yourself. Fortunately spring is quite flexible framework so it is not a big deal to configure it.</p>

<p>Let me show you little guide how to do this for Grails application. <!--more--> First you have to enable springSecurityEventListener in your Config.groovy grails.plugins.springsecurity.useSecurityEventListener = true</p>

<p>then implement listeners in /src/bruteforce create classes {% codeblock lang:groovy %}</p>

<p>/** Registers all failed attempts to login. Main purpose to count attempts for particular account ant block user</p>

<p><em>/ class AuthenticationFailureListener implements ApplicationListener {</em></p>

<pre><code>LoginAttemptCacheService loginAttemptCacheService

@Override
void onApplicationEvent(AuthenticationFailureBadCredentialsEvent e) {
    loginAttemptCacheService.failLogin(e.authentication.name)
}</code></pre>

<p>} {% endcodeblock %} next we have to create listener for successful logins in same package {% codeblock lang:groovy %}</p>

<p>/** Listener for successfull logins. Used for reseting number on unsuccessfull logins for specific account <em>/ class AuthenticationSuccessEventListener implements ApplicationListener{</em></p>

<pre><code>LoginAttemptCacheService loginAttemptCacheService

@Override
void onApplicationEvent(AuthenticationSuccessEvent e) {
    loginAttemptCacheService.loginSuccess(e.authentication.name)
}</code></pre>

<p>} {% endcodeblock %} We were not putting them in our grails-app folder so we need to register these classes as spring beans. Add next lines into grails-app/conf/spring/resources.groovy {% codeblock lang:groovy %}</p>

<p>beans = { authenticationFailureListener(AuthenticationFailureListener) { loginAttemptCacheService = ref(&#8216;loginAttemptCacheService&#8217;) }</p>

<pre><code>authenticationSuccessEventListener(AuthenticationSuccessEventListener) {
    loginAttemptCacheService = ref(&#39;loginAttemptCacheService&#39;)
}</code></pre>

<p>} {% endcodeblock %} You&#8217;ve probably notice usage of LoginAttemptCacheService loginAttemptCacheService Let&#8217;s implement it. This would be typical grails service {% codeblock lang:groovy %}</p>

<p>package com.grygoriy</p>

<p>import com.google.common.cache.CacheBuilder import com.google.common.cache.CacheLoader import com.google.common.cache.LoadingCache</p>

<p>import java.util.concurrent.TimeUnit import org.apache.commons.lang.math.NumberUtils import javax.annotation.PostConstruct</p>

<p>class LoginAttemptCacheService {</p>

<pre><code>private LoadingCache attempts;
private int allowedNumberOfAttempts
def grailsApplication

@PostConstruct
void init() {
    allowedNumberOfAttempts = grailsApplication.config.brutforce.loginAttempts.allowedNumberOfAttempts
    int time = grailsApplication.config.brutforce.loginAttempts.time

    log.info &quot;account block configured for $time minutes&quot;
    attempts = CacheBuilder.newBuilder()
               .expireAfterWrite(time, TimeUnit.MINUTES)
               .build({0} as CacheLoader);
}

/**
 * Triggers on each unsuccessful login attempt and increases number of attempts in local accumulator
 * @param login - username which is trying to login
 * @return
 */
def failLogin(String login) {
    def numberOfAttempts = attempts.get(login)
    log.debug &quot;fail login $login previous number for attempts $numberOfAttempts&quot;
    numberOfAttempts++

    if (numberOfAttempts &amp;gt; allowedNumberOfAttempts) {
        blockUser(login)
        attempts.invalidate(login)
    } else {
        attempts.put(login, numberOfAttempts)
    }
}

/**
 * Triggers on each successful login attempt and resets number of attempts in local accumulator
 * @param login - username which is login
 */
def loginSuccess(String login) {
    log.debug &quot;successfull login for $login&quot;
    attempts.invalidate(login)
}

/**
 * Disable user account so it would not able to login
 * @param login - username that has to be disabled
 */
private void blockUser(String login) {
    log.debug &quot;blocking user: $login&quot;
    def user = User.findByUsername(login)
    if (user) {
        user.accountLocked = true;
        user.save(flush: true)
    }
}</code></pre>

<p>} {% endcodeblock %} We will be using CacheBuilder from google guava library. So please add next lines to BuildConfig.groovy {% codeblock lang:groovy %}</p>

<pre><code>dependencies {
    runtime &#39;com.google.guava:guava:11.0.1&#39;
}</code></pre>

<p>{% endcodeblock %} And the last step we will add service configuration to Config.groovy {% codeblock lang:groovy %}</p>

<p>brutforce { loginAttempts { time = 5 allowedNumberOfAttempts = 3 } {% endcodeblock %} That is it, you ready to run you application. For typical java project almost everything will be the same. Same listeners and same services.</p>

<p>More about Spring Security Events More about caching with Google guava</p>

<p>Grails users can simple use this plugin https://github.com/grygoriy/bruteforcedefender UPD: Plugin now at http://grails.org/plugin/bruteforce-defender Enjoy :)</p>]]></content>
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Grails | Grygoriy Mykhalyuno]]></title>
  <link href="http://grygoriy.github.io/blog/categories/grails/atom.xml" rel="self"/>
  <link href="http://grygoriy.github.io/"/>
  <updated>2013-10-12T01:02:37+03:00</updated>
  <id>http://grygoriy.github.io/</id>
  <author>
    <name><![CDATA[Grygoriy Mykhalyuno]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Deleting grails domain entity without fetching it]]></title>
    <link href="http://grygoriy.github.io/blog/2012/10/24/deleting-grails-domain-entity-without-fetching-it/"/>
    <updated>2012-10-24T15:52:00+03:00</updated>
    <id>http://grygoriy.github.io/blog/2012/10/24/deleting-grails-domain-entity-without-fetching-it</id>
    <content type="html"><![CDATA[<p>So many times I&#8217;ve seen how people working with Hibernate and complaining how slow it is. What I actually see, is how people do not care about tools that they are using. They have strange assumption if tool supposed to their life easier then it supposes to 100% easier and no reason to read posts about such tool or investigate how it can be configured. Here is only on tip how to avoid useless selects hibernate or Grails GORM. Imaging you have an application that manipulates some data, lets say Comments. There is also controller or some API to delete one comment. If request comes from somewhere outside you application usually it looks like delete something with id=1. http://localhost/comments/delete/1 Implementation of controller usually looks like {% codeblock lang:groovy %} def deleteComment() { def commentId = params.long(&#8216;id&#8217;) def comment = Comment.findById(commentId) comment?.delete() } {% endcodeblock %} So bad part on this example is that we fetch from database entity that we do not need at all. We want to delete it. Hibernate and so GORM are working objects and not with parts of its fields. But it doesn&#8217;t mean that you cannot do it, just use HQL. Here is simple HQL that will generates pure delete SQL query. Comments.executeUpdate(&#8220;delete from Comments where id = :id&#8221;, <span>id:commentId</span>) Of cause you would like to write such code whenever you will need to delete entity, so we will add dynamic method to each Domain class in our application. Please add next code to your BootStrap.groovy {% codeblock lang:groovy %} def grailsApplication</p>

<pre><code>def init = { servletContext -&gt;
    grailsApplication.domainClasses.each {def domain -&gt;
        domain.metaClass.static.deleteById = {def id -&gt;
            executeUpdate(&quot;delete from ${domain.name} where id = :id&quot;, [id:id])
        }
    }
}</code></pre>

<p>{% endcodeblock %} Now each of your domain class has the method deleteById, and our example became {% codeblock lang:groovy %} def deleteComment() { def commentId = params.long(&#8216;id&#8217;) Comment.deleteById(commentId) } {% endcodeblock %} You can use this Grails plugin https://github.com/grygoriy/grails_gorm_utils that adds this method for you. Enjoy!</p>]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Prevent brute force attack with Spring Security]]></title>
    <link href="http://grygoriy.github.io/blog/2012/10/06/prevent-brute-force-attack-with-spring-security/"/>
    <updated>2012-10-06T15:58:00+03:00</updated>
    <id>http://grygoriy.github.io/blog/2012/10/06/prevent-brute-force-attack-with-spring-security</id>
    <content type="html"><![CDATA[<p>Spring Security can do lot of stuff for you. Account blocking, password salt. But what about brute force blocker. That what you have to do by yourself. Fortunately spring is quite flexible framework so it is not a big deal to configure it.</p>

<p>Let me show you little guide how to do this for Grails application. <!--more--> First you have to enable springSecurityEventListener in your Config.groovy grails.plugins.springsecurity.useSecurityEventListener = true</p>

<p>then implement listeners in /src/bruteforce create classes {% codeblock lang:groovy %}</p>

<p>/** Registers all failed attempts to login. Main purpose to count attempts for particular account ant block user</p>

<p><em>/ class AuthenticationFailureListener implements ApplicationListener {</em></p>

<pre><code>LoginAttemptCacheService loginAttemptCacheService

@Override
void onApplicationEvent(AuthenticationFailureBadCredentialsEvent e) {
    loginAttemptCacheService.failLogin(e.authentication.name)
}</code></pre>

<p>} {% endcodeblock %} next we have to create listener for successful logins in same package {% codeblock lang:groovy %}</p>

<p>/** Listener for successfull logins. Used for reseting number on unsuccessfull logins for specific account <em>/ class AuthenticationSuccessEventListener implements ApplicationListener{</em></p>

<pre><code>LoginAttemptCacheService loginAttemptCacheService

@Override
void onApplicationEvent(AuthenticationSuccessEvent e) {
    loginAttemptCacheService.loginSuccess(e.authentication.name)
}</code></pre>

<p>} {% endcodeblock %} We were not putting them in our grails-app folder so we need to register these classes as spring beans. Add next lines into grails-app/conf/spring/resources.groovy {% codeblock lang:groovy %}</p>

<p>beans = { authenticationFailureListener(AuthenticationFailureListener) { loginAttemptCacheService = ref(&#8216;loginAttemptCacheService&#8217;) }</p>

<pre><code>authenticationSuccessEventListener(AuthenticationSuccessEventListener) {
    loginAttemptCacheService = ref(&#39;loginAttemptCacheService&#39;)
}</code></pre>

<p>} {% endcodeblock %} You&#8217;ve probably notice usage of LoginAttemptCacheService loginAttemptCacheService Let&#8217;s implement it. This would be typical grails service {% codeblock lang:groovy %}</p>

<p>package com.grygoriy</p>

<p>import com.google.common.cache.CacheBuilder import com.google.common.cache.CacheLoader import com.google.common.cache.LoadingCache</p>

<p>import java.util.concurrent.TimeUnit import org.apache.commons.lang.math.NumberUtils import javax.annotation.PostConstruct</p>

<p>class LoginAttemptCacheService {</p>

<pre><code>private LoadingCache attempts;
private int allowedNumberOfAttempts
def grailsApplication

@PostConstruct
void init() {
    allowedNumberOfAttempts = grailsApplication.config.brutforce.loginAttempts.allowedNumberOfAttempts
    int time = grailsApplication.config.brutforce.loginAttempts.time

    log.info &quot;account block configured for $time minutes&quot;
    attempts = CacheBuilder.newBuilder()
               .expireAfterWrite(time, TimeUnit.MINUTES)
               .build({0} as CacheLoader);
}

/**
 * Triggers on each unsuccessful login attempt and increases number of attempts in local accumulator
 * @param login - username which is trying to login
 * @return
 */
def failLogin(String login) {
    def numberOfAttempts = attempts.get(login)
    log.debug &quot;fail login $login previous number for attempts $numberOfAttempts&quot;
    numberOfAttempts++

    if (numberOfAttempts &amp;gt; allowedNumberOfAttempts) {
        blockUser(login)
        attempts.invalidate(login)
    } else {
        attempts.put(login, numberOfAttempts)
    }
}

/**
 * Triggers on each successful login attempt and resets number of attempts in local accumulator
 * @param login - username which is login
 */
def loginSuccess(String login) {
    log.debug &quot;successfull login for $login&quot;
    attempts.invalidate(login)
}

/**
 * Disable user account so it would not able to login
 * @param login - username that has to be disabled
 */
private void blockUser(String login) {
    log.debug &quot;blocking user: $login&quot;
    def user = User.findByUsername(login)
    if (user) {
        user.accountLocked = true;
        user.save(flush: true)
    }
}</code></pre>

<p>} {% endcodeblock %} We will be using CacheBuilder from google guava library. So please add next lines to BuildConfig.groovy {% codeblock lang:groovy %}</p>

<pre><code>dependencies {
    runtime &#39;com.google.guava:guava:11.0.1&#39;
}</code></pre>

<p>{% endcodeblock %} And the last step we will add service configuration to Config.groovy {% codeblock lang:groovy %}</p>

<p>brutforce { loginAttempts { time = 5 allowedNumberOfAttempts = 3 } {% endcodeblock %} That is it, you ready to run you application. For typical java project almost everything will be the same. Same listeners and same services.</p>

<p>More about Spring Security Events More about caching with Google guava</p>

<p>Grails users can simple use this plugin https://github.com/grygoriy/bruteforcedefender UPD: Plugin now at http://grails.org/plugin/bruteforce-defender Enjoy :)</p>]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Working with more then one grails version on same environment]]></title>
    <link href="http://grygoriy.github.io/blog/2012/09/23/working-with-more-then-one-grails-version-on-same-environment/"/>
    <updated>2012-09-23T19:04:00+03:00</updated>
    <id>http://grygoriy.github.io/blog/2012/09/23/working-with-more-then-one-grails-version-on-same-environment</id>
    <content type="html"><![CDATA[<p>Typically you have your grails installed into some directory, created environment variable GRAILS_HOME and you are ready to go.</p>

<p>But what if you have few projects with different grails versions? You can have different reasons for that, but nevertheless you need it.</p>

<p>Here is short tip how this process can be simplified, example for Linux (Ubuntu). Usually I install all applications to /usr/local/. Let&#8217;s try to work with two grails versions 2.0.0 and 2.1.1(latest for this period) So after unpacking we have {% codeblock lang:sh %}</p>

<p>/usr/local/grails-2.0.0 /usr/local/grails-2.1.1 {% endcodeblock %} Let&#8217;s create link to any version of Grails {% codeblock lang:sh %}</p>

<blockquote>
<p>ln -s /usr/local/grails-2.1.1 grails</p>
</blockquote>

<p>{% endcodeblock %} Now we have {% codeblock lang:sh %} /usr/local$ ls -ld grails* lrwxrwxrwx &#160;1 root root &#160; 23 Sep 23 15:05 grails -&#62; /usr/local/grails-2.1.1 drwxr-xr-x 12 root root 4096 Dec 15 &#160;2011 grails-2.0.0 drwxr-xr-x 13 root root 4096 Sep 12 10:30 grails-2.1.1 {% endcodeblock %}</p>

<p>and variable</p>

<p>{% codeblock lang:sh %} echo $GRAILS_HOME /usr/local/grails {% endcodeblock %} Let&#8217;s use simple script to change grails version. Mainly the only thing we have to do is to reassign link /usr/local/grails to version we would like to use {% codeblock lang:sh %}</p>

<h1 id='binbash'>!/bin/bash</h1>

<h1 id='script_for_changing_grails_version'>Script for changing grails version</h1>

<p>grailsVersion=$1 rootPath=&#8221;/usr/local&#8221; grailsLinkPath=$rootPath&#8221;/grails&#8221; grailsPath=$grailsLinkPath&#8221;-&#8220;$grailsVersion</p>

<p>echo stitching to version $1</p>

<h1 id='check_if_directory_with_new_grails_version_exists_before_doing_anything'>Check if directory with new grails version exists before doing anything</h1>

<p><span>-d $grailsPath</span> &#38;&#38; rm $grailsLinkPath &#38;&#38; ln -s $grailsPath $grailsLinkPath &#38;&#38; echo &#8220;version switched to &#8220;$grailsVersion || echo &#8216;Directory &#8216;$grailsPath&#8217; not found&#8217; {% endcodeblock %}</p>]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to run Grails application on separate port]]></title>
    <link href="http://grygoriy.github.io/blog/2012/02/06/how-to-run-grails-application-on-separate-port/"/>
    <updated>2012-02-06T18:30:00+02:00</updated>
    <id>http://grygoriy.github.io/blog/2012/02/06/how-to-run-grails-application-on-separate-port</id>
    <content type="html"><![CDATA[<p>Some times you need to run your Grails app on different port and different context during development. Typical example when you are developing application that is divided into two or more apps (Services or other) So one application will run on 8080 and other for example 8081. That&#8217;s allows you to run both applications in same time, work with them and debug</p>

<p>So we can change port with command <br /> <strong>grails run-app -Dserver.port=8081</strong></p>

<p>But it is not very convenient to do it all the time, so I prefer to change it in BuildConfig.groovy, just put next line somewhere in file <br /> <strong>grails.server.port.http=&#8221;8081&#8221;</strong></p>

<p>and to change running context (default is localhost:8080/appname) add app.context= to application.properties. Next line will run Grails application at root context <br /> <strong>app.context=/</strong></p>]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[use Grails Domain with string type id]]></title>
    <link href="http://grygoriy.github.io/blog/2012/01/03/use-grails-domain-with-string-type-id/"/>
    <updated>2012-01-03T18:41:00+02:00</updated>
    <id>http://grygoriy.github.io/blog/2012/01/03/use-grails-domain-with-string-type-id</id>
    <content type="html"><![CDATA[<p>Some times you need id with different type then Long. It doesn’t metter you have lagacy database or it requirement from your DBA.</p>

<p>In general all you need is described in official docs <a href='http://grails.org/doc/2.0.x/ref/Database%20Mapping/id.html'>http://grails.org/doc/2.0.x/ref/Database Mapping/id.html</a></p>

<p>But there is at least one case with very strange behaviour. When we define key as String type</p>

<p>{% codeblock lang:groovy %} Foo { static mapping = { id name: &#8216;code&#8217;, column: &#8216;code&#8217;, type: &#8216;string&#8217; } }</p>

<p>{% endcodeblock %}</p>

<p>For the first look it works fine Foo.get(‘someKey’) returns exact object I was looking. But when we try to use string that looks like a number</p>

<p>{% codeblock lang:groovy %} Foo.get(&#8216;4’) {% endcodeblock %} we will get</p>

<p>{% codeblock lang:groovy %} org.hibernate.TypeMismatchException {% endcodeblock %}</p>

<p>Provided id of the wrong type for class Foo. Expected: class java.lang.String, got class java.lang.Long It looks like id field is still Long and grails first of all trying to cast serializable to Long and only after that it looks for type property. Workaround is to add explicitly id field to domain class</p>

<p>{% codeblock lang:groovy %} Foo { String id</p>

<p>static mapping = { id name: &#8216;code&#8217;, column: &#8216;code&#8217;, type: &#8216;string&#8217; } } {% endcodeblock %}</p>

<p>It is mentioned in documentation but now grails knows what type to use. There is issue in grails jira which was closed with resolution Not A Bug.</p>]]></content>
  </entry>
  
</feed>
